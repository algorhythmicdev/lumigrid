0) Where to put things
components/
  led_effects/
    effects.h               // extend params + enums
    effects.c               // register + base fx + NEW fx
    fx_util.h/.c            // NEW: gamma, hsv/rgbw, dither
    fx_blend.h/.c           // NEW: Normal/Add/Screen/Multiply/Lighten
    fx_palette.h/.c         // NEW: discrete key palettes w/ lerp
    fx_segments.h/.c        // NEW: per-clip virtual subranges
    fx_transitions.h/.c     // NEW: crossfades between presets
  aled_rmt/
    aled_rmt.h/.c           // your RMT writer (full WS2812 timing below)
  pca9685_driver/
    pca9685_driver.h/.c     // already there (PWM HAL)
main/
  tasks/task_effect_engine.c // render order, fairness, power clamp
  utils/power_budget.h/.c    // NEW: mA modeling + global scaler
  utils/trigger_engine.c/.h  // beat hooks, strobe
  rest/api_handlers.c        // endpoints for presets, cue, trigger
tests/
  test_fx_crc.c              // golden frame CRCs

1) Effect API upgrade (small, powerful)
effects.h — add blend + segments + opacity
typedef enum { BLEND_NORMAL, BLEND_ADD, BLEND_SCREEN, BLEND_MULTIPLY, BLEND_LIGHTEN } blend_mode_t;

typedef struct {
  uint32_t effect_id;
  float    speed;          // cycles/s or px/s (effect-defined)
  float    intensity;      // 0..1 scalar
  uint32_t palette_id;     // 0..N (into fx_palette registry)
  px_rgba_t color1, color2, color3;
  uint32_t seed;           // stable per-instance
  blend_mode_t blend;      // overlay blending
  uint8_t  opacity;        // 0..255 overlay opacity
  uint16_t seg_start;      // virtual segment start within channel
  uint16_t seg_len;        // 0 = full length
} effect_params_t;

// render now returns an estimated “brightness sum” you’ll map to mA
typedef uint32_t (*fx_render_fn)(aled_channel_t*, const effect_params_t*, uint32_t t_ms, uint32_t t_end_ms);

2) Utilities: gamma, hsv→rgbw, ordered dither

fx_util.h

#pragma once
#include "effects.h"
void     util_init_gamma(float gamma);
uint8_t  util_gamma_u8(uint8_t v);
px_rgba_t hsv_to_rgbw(float h, float s, float v, int rgbw);
uint8_t  dither_ordered(uint8_t v8, uint16_t x, uint16_t y, uint32_t t_ms);


fx_util.c (core bits)

static uint8_t G[256];
void util_init_gamma(float g){ for(int i=0;i<256;i++){ G[i]=(uint8_t)(powf(i/255.f,g)*255.f+.5f);} }
uint8_t util_gamma_u8(uint8_t v){ return G[v]; }

static const uint8_t B4[4][4]={{0,8,2,10},{12,4,14,6},{3,11,1,9},{15,7,13,5}};
uint8_t dither_ordered(uint8_t v, uint16_t x, uint16_t y, uint32_t t){
  uint8_t b=B4[y&3][x&3], j=(t>>4)&3; int out=v+((b+j)>8); return out<0?0:(out>255?255:out);
}

px_rgba_t hsv_to_rgbw(float h,float s,float v,int rgbw){
  h=fmodf(h,1.f); if(h<0) h+=1.f;
  float r,g,b; float i=floorf(h*6), f=h*6-i;
  float p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
  switch((int)i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;
  case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;default:r=v;g=p;b=q;break;}
  px_rgba_t c={(uint8_t)(r*255),(uint8_t)(g*255),(uint8_t)(b*255),0};
  if(rgbw){ uint8_t w=(uint8_t)fminf(fminf(c.r,c.g),c.b); c.r-=w; c.g-=w; c.b-=w; c.w=w; }
  return c;
}

3) Blend ops

fx_blend.h

#pragma once
#include "effects.h"
static inline uint8_t clamp8i(int v){ return v<0?0:(v>255?255:v); }

static inline px_rgba_t blend_apply(blend_mode_t m, px_rgba_t base, px_rgba_t over){
  px_rgba_t o=base;
  switch(m){
    case BLEND_ADD:      o.r=clamp8i(base.r+over.r); o.g=clamp8i(base.g+over.g); o.b=clamp8i(base.b+over.b); o.w=clamp8i(base.w+over.w); break;
    case BLEND_SCREEN:   o.r=255-((255-base.r)*(255-over.r)/255);
                         o.g=255-((255-base.g)*(255-over.g)/255);
                         o.b=255-((255-base.b)*(255-over.b)/255);
                         o.w=clamp8i(base.w+over.w); break;
    case BLEND_MULTIPLY: o.r=(base.r*over.r)/255; o.g=(base.g*over.g)/255; o.b=(base.b*over.b)/255; o.w=clamp8i(base.w+over.w); break;
    case BLEND_LIGHTEN:  o.r=base.r>over.r?base.r:over.r; o.g=base.g>over.g?base.g:over.g; o.b=base.b>over.b?base.b:over.b; o.w=clamp8i(base.w+over.w); break;
    default:             o=over; break;
  } return o;
}

4) Palettes & segments

fx_palette.h/c

// .h
typedef struct { uint8_t r,g,b; } rgb8_t;
typedef struct { const char* name; const rgb8_t* keys; uint8_t count; } palette_t;
const palette_t* palette_by_id(uint32_t id);
rgb8_t palette_sample(const palette_t* p, float t);

// .c
static const rgb8_t PAL_OCEAN[]  = {{0,64,128},{0,160,255},{0,64,128}};
static const rgb8_t PAL_SUNSET[] = {{255,80,0},{255,0,64},{64,0,96}};
static const palette_t REGS[] = { {"ocean",PAL_OCEAN,3}, {"sunset",PAL_SUNSET,3} };
const palette_t* palette_by_id(uint32_t id){ return id<2? &REGS[id] : &REGS[0]; }
rgb8_t palette_sample(const palette_t* p, float t){
  float x=t*(p->count-1); int i=(int)floorf(x); float u=x-i;
  rgb8_t a=p->keys[i], b=p->keys[i<p->count-1?i+1:i];
  return (rgb8_t){ a.r+(uint8_t)((b.r-a.r)*u), a.g+(uint8_t)((b.g-a.g)*u), a.b+(uint8_t)((b.b-a.b)*u) };
}


fx_segments.h

#pragma once
#include "effects.h"
typedef struct { uint16_t start,len; } segment_t;
static inline segment_t seg_from_params(const aled_channel_t* ch, const effect_params_t* p){
  segment_t s={p->seg_start, p->seg_len?p->seg_len:ch->n_pixels};
  if(s.start>=ch->n_pixels){ s.start=0; s.len=ch->n_pixels; }
  if(s.start+s.len>ch->n_pixels) s.len=ch->n_pixels-s.start;
  return s;
}

5) New addressable FX (drop straight into effects.c)

Utilities:

static float hash11(float p){ p = sinf(p*127.1f)*43758.5453f; return p - floorf(p); }
static float noise1(float x){ float i=floorf(x), f=x-i; float a=hash11(i), b=hash11(i+1.f); return a + (b-a)*(f*f*(3-2*f)); }

5.1 Rainbow (palette-aware, gamma+dither)
static uint32_t fx_rainbow(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s = seg_from_params(ch,p);
  const palette_t* pal = palette_by_id(p->palette_id);
  float spd = p->speed>0 ? p->speed : 0.2f; float t = (t_ms/1000.f)*spd;
  uint32_t sum=0;
  for(int i=0;i<s.len;i++){
    float u = fmodf((i/(float)s.len)+t,1.f);
    rgb8_t c = palette_sample(pal,u);
    px_rgba_t px = { util_gamma_u8(dither_ordered(c.r,i,ch->ch,t_ms)),
                     util_gamma_u8(dither_ordered(c.g,i,ch->ch,t_ms)),
                     util_gamma_u8(dither_ordered(c.b,i,ch->ch,t_ms)), 0 };
    ch->framebuf[s.start+i]=px; sum+=px.r+px.g+px.b;
  }
  return sum;
}

5.2 Fire (classic, SK6812-friendly)
static uint32_t fx_fire(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s=seg_from_params(ch,p); uint32_t sum=0;
  for(int i=0;i<s.len;i++){
    float y=(float)i/s.len;
    float flick = noise1(i*0.15f + t_ms*0.006f + p->seed)*0.7f + 0.3f;
    float heat = powf(1.0f-y,2.0f) * flick * (p->intensity>0?p->intensity:1.0f);
    px_rgba_t px = hsv_to_rgbw(0.06f+0.05f*(1.f-heat), 1.0f, heat, ch->type==LED_SK6812_RGBW);
    ch->framebuf[s.start+i]=px; sum+=px.r+px.g+px.b+px.w;
  } return sum;
}

5.3 Noise Flow
static uint32_t fx_noise(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s=seg_from_params(ch,p); float spd = p->speed>0?p->speed:1.2f;
  float t = (t_ms/1000.f)*spd + p->seed*0.1f; uint32_t sum=0;
  for(int i=0;i<s.len;i++){
    float v = powf(noise1(i*0.08f+t), 1.5f) * (p->intensity>0?p->intensity:1.f);
    px_rgba_t px = { (uint8_t)(p->color1.r*v),(uint8_t)(p->color1.g*v),(uint8_t)(p->color1.b*v),0 };
    ch->framebuf[s.start+i]=px; sum+=px.r+px.g+px.b;
  } return sum;
}

5.4 Waves (beat-reactive)
extern volatile float g_beat_phase; // 0..1, set via trigger or detector
static uint32_t fx_waves(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s=seg_from_params(ch,p); float t=t_ms/1000.f; uint32_t sum=0;
  for(int i=0;i<s.len;i++){
    float x=(float)i/s.len;
    float w=0.5f+0.5f*sinf(x*6.283f*(1.5f+p->intensity*2.f)+t*2.0f+g_beat_phase*3.1415f);
    px_rgba_t a=p->color1, b=p->color2;
    px_rgba_t px={ a.r+(uint8_t)((b.r-a.r)*w), a.g+(uint8_t)((b.g-a.g)*w), a.b+(uint8_t)((b.b-a.b)*w),0 };
    ch->framebuf[s.start+i]=px; sum+=px.r+px.g+px.b;
  } return sum;
}

Register them (IDs stable for presets)
enum { FX_SOLID=1, FX_GRADIENT=2, FX_CHASE=3, FX_TWINKLE=4,
       FX_RAINBOW=1001, FX_NOISE=1002, FX_FIRE=1003, FX_WAVES=1004 };

static const effect_vtable_t EFFECTS[] = {
  {FX_SOLID,   "solid",    fx_solid_init,   fx_solid},
  {FX_GRADIENT,"gradient", fx_gradient_init,fx_gradient},
  {FX_CHASE,   "chase",    fx_chase_init,   fx_chase},
  {FX_TWINKLE, "twinkle",  fx_twinkle_init, fx_twinkle},
  {FX_RAINBOW, "rainbow",  NULL,            fx_rainbow},
  {FX_NOISE,   "noise",    NULL,            fx_noise},
  {FX_FIRE,    "fire",     NULL,            fx_fire},
  {FX_WAVES,   "waves",    NULL,            fx_waves},
};

6) PWM “effects” (warm dim, breath, candle, theater fade)

In task_pwm_driver.c

void pwm_breath(uint8_t ch, float minv, float maxv, float period_ms, uint32_t t_ms){
  float s = 0.5f - 0.5f*cosf(fmodf(t_ms/period_ms,1.f)*6.283f);
  pca9685_set_duty(ch, minv + (maxv-minv)*s);
}

void pwm_candle(uint8_t ch, float base, float flick, uint32_t t_ms, uint32_t seed){
  uint32_t x = (t_ms*1664525u + seed*1013904223u);
  float n = ((x>>8)&0xFFFF)/65535.f; float d=base + (n-0.5f)*flick;
  if(d<0) d=0; if(d>1) d=1; pca9685_set_duty(ch, d);
}

void pwm_warmdim(uint8_t ch, float duty){
  // optional: map duty to CCT if you have tunable whites; otherwise just gamma
  float g = powf(duty, 2.0f);
  pca9685_set_duty(ch, g);
}


Drive these from Scheduler or /api/trigger (preset type pwm).

7) Transitions (crossfade between presets)

fx_transitions.h/c

// fx_transitions.h
#pragma once
#include "effects.h"
typedef struct { uint32_t t0,t1; uint8_t active; } xfade_t;
void xfade_begin(xfade_t* x, uint32_t now, uint32_t ms);
float xfade_mix(const xfade_t* x, uint32_t now);

// fx_transitions.c
void xfade_begin(xfade_t* x, uint32_t now, uint32_t ms){ x->t0=now; x->t1=now+ms; x->active=ms>0; }
float xfade_mix(const xfade_t* x, uint32_t now){
  if(!x->active || now>=x->t1) return 1.f;
  if(now<=x->t0) return 0.f;
  float u=(now-x->t0)/(float)(x->t1-x->t0); // 0..1
  // smootherstep
  return u*u*(3-2*u);
}


In task_effect_engine.c, keep two “programs” (current / next). While xfade.active, render both to A/B buffers and lerp before blend/power-clamp.

8) Power budgeting v2 (less hand-wavy)

utils/power_budget.h/c

// .h
#pragma once
#include "effects.h"
typedef struct { float per_led_mA; float limit_mA; } power_cfg_t;
void  power_set_cfg(power_cfg_t);
float power_scale_for_frame(px_rgba_t* fb, int n, const power_cfg_t* cfg);

// .c
float power_scale_for_frame(px_rgba_t* fb,int n,const power_cfg_t* c){
  // naive: 255 RGBW sum ≈ c->per_led_mA (e.g., 60mA for RGBW full)
  uint32_t sum=0; for(int i=0;i<n;i++){ sum += fb[i].r + fb[i].g + fb[i].b + fb[i].w; }
  float est_mA = (sum/(255.f))* (c->per_led_mA/4.f); // 4 channels (RGBW), adjust for RGB
  return est_mA>c->limit_mA ? (c->limit_mA/est_mA) : 1.f;
}


Engine usage:

float s = power_scale_for_frame(ch->framebuf, ch->n_pixels, &g_power_cfg);
if(s<1.f){ for(int i=0;i<ch->n_pixels;i++){ ch->framebuf[i].r*=s; ch->framebuf[i].g*=s; ch->framebuf[i].b*=s; ch->framebuf[i].w*=s; } }

9) RMT WS2812 timing (no libraries, tight)

aled_rmt.h/c (core writer)

// aled_rmt.h
#pragma once
#include "driver/rmt_tx.h"
#include "effects.h"
esp_err_t aled_rmt_init_chan(int idx, gpio_num_t pin);
esp_err_t aled_rmt_write(int idx, const px_rgba_t* fb, int npx, led_type_t type);

// aled_rmt.c
static rmt_channel_handle_t CH[8];
static rmt_encoder_handle_t enc;

esp_err_t aled_rmt_init_chan(int idx, gpio_num_t pin){
  rmt_tx_channel_config_t c = {
    .gpio_num = pin, .clk_src = RMT_CLK_SRC_DEFAULT, .mem_block_symbols=96,
    .resolution_hz = 10*1000*1000, .trans_queue_depth=4
  };
  ESP_ERROR_CHECK(rmt_new_tx_channel(&c, &CH[idx]));
  rmt_bytes_encoder_config_t ec={}; ESP_ERROR_CHECK(rmt_new_bytes_encoder(&ec,&enc));
  return rmt_enable(CH[idx]);
}

// Build raw bytes (GRB or GRBW), then encode into RMT “1”/“0” timings using bytes encoder’s copy mode
typedef struct { uint16_t t1h,t1l,t0h,t0l; } ws_timing_t;
static inline ws_timing_t ws2812_t(){ return (ws_timing_t){ .t1h=8, .t1l=4, .t0h=4, .t0l=9 }; } // 100ns ticks

esp_err_t aled_rmt_write(int idx, const px_rgba_t* fb, int npx, led_type_t type){
  static uint8_t line[4*1024]; // up to ~1024 RGBW px; adjust/stream if needed
  int stride = (type==LED_SK6812_RGBW)?4:3, pos=0;
  for(int i=0;i<npx;i++){
    // GRB(W) order expected by most strips
    line[pos++] = fb[i].g; line[pos++] = fb[i].r; line[pos++] = fb[i].b;
    if(stride==4) line[pos++] = fb[i].w;
  }
  // Convert to RMT symbols with custom translator
  // The bytes encoder can’t apply timings itself; so create a translator:
  rmt_symbol_word_t symbols[16]; // ring buffer chunk
  rmt_tx_transmit_config_t tc={ .loop_count = 0 };
  // Provide a translator function (once) with rmt_register_tx_end_callback or rmt_translator, but in IDF 5: use rmt_new_bytes_encoder + rmt_encode_xxx is limited.
  // Practical approach: build your own encoder (omitted full code for brevity):
  // -> For each bit (MSB first): T1 = {t1h,t1l}, T0 = {t0h,t0l}. Push into ring, then transmit.
  // For production, reuse known-good tiny encoders or ESP-IDF ws2812 example.

  return rmt_transmit(CH[idx], enc, line, pos, &tc); // works if you supply a translator; else replace with custom encoder
}


If you don’t want to write a full encoder today, pull IDF’s ws2812 example encoder and wrap it—keep the public aled_rmt_write() API stable so you can swap implementations later.

10) Engine: render order, blending, clamp, fairness

In task_effect_engine.c

static power_cfg_t g_power = {.per_led_mA=60.f, .limit_mA=8000.f};

static void render_one(int i, uint32_t now){
  aled_channel_t* ch = &aled[i];

  // Base
  const effect_vtable_t* base = fx_lookup(active[i].base.effect_id);
  memset(ch->framebuf,0,sizeof(px_rgba_t)*ch->n_pixels);
  if(base) base->render(ch, &active[i].base, now, active[i].t_end);

  // Overlay
  if(active[i].overlay_active){
    px_rgba_t tmp[CH_MAX]; memcpy(tmp,ch->framebuf,sizeof(px_rgba_t)*ch->n_pixels);
    const effect_vtable_t* ovl = fx_lookup(active[i].overlay.effect_id);
    if(ovl){ ovl->render(ch, &active[i].overlay, now, active[i].t_end);
      // opacity + blend
      for(int p=0;p<ch->n_pixels;p++){
        px_rgba_t b=ch->framebuf[p]; b.r=(b.r*active[i].overlay.opacity)/255; b.g=(b.g*...)/255; b.b=(b.b*...)/255; b.w=(b.w*...)/255;
        ch->framebuf[p] = blend_apply(active[i].overlay.blend, tmp[p], b);
      }
    } else memcpy(ch->framebuf,tmp,sizeof(px_rgba_t)*ch->n_pixels);
  }

  // Power clamp
  float s = power_scale_for_frame(ch->framebuf, ch->n_pixels, &g_power);
  if(s<1.f){ for(int p=0;p<ch->n_pixels;p++){ ch->framebuf[p].r*=s; ch->framebuf[p].g*=s; ch->framebuf[p].b*=s; ch->framebuf[p].w*=s; } }

  // Push
  aled_rmt_write(i, ch->framebuf, ch->n_pixels, ch->type);
}

// fairness: schedule channels by next_deadline

11) Beat/strobe hooks (tiny and useful)

utils/trigger_engine.c

volatile float g_beat_phase = 0.f; // read by fx_waves()
void trigger_set_beat(float phase01){ g_beat_phase = fmodf(phase01,1.f); }
void trigger_strobe(uint32_t ms){ /* set a global “flash” scalar used by FX for white hits */ }


Expose via REST:

POST /api/trigger
{"action":"beat","phase":0.0}

12) Presets & Clips (JSON examples)

Addressable

{
  "preset_name":"ocean_walk",
  "effect_id":1001, "palette_id":0,
  "speed":0.18, "intensity":1.0, "blend":"normal", "opacity":255,
  "seg_start":0, "seg_len":120
}


PWM

{"preset_name":"breath_warm","type":"pwm","channel":3,"mode":"breath","min":0.05,"max":0.6,"period_ms":2800}


Sequencer clip

{"track":"ALEDch3","preset":"ocean_walk","tStart":12000,"tEnd":42000,"fadeIn":400,"fadeOut":500}

13) REST glue (handlers)

/api/presets — upsert

static esp_err_t post_preset(httpd_req_t* r){
  char buf[4096]; int n=httpd_req_recv(r,buf,sizeof(buf)-1); if(n<0) return ESP_FAIL; buf[n]=0;
  // parse name/effect_id/params → write to /spiffs/presets/<name>.json (atomic swap)
  httpd_resp_sendstr(r,"OK"); return ESP_OK;
}


/api/trigger — play preset / set pwm / blackout / beat

static esp_err_t post_trigger(httpd_req_t* r){
  // action: "play_preset" | "set_pwm" | "blackout" | "beat"
  // target: "ALEDchN"/"LEDchN"
  // name: preset_name for play_preset
  // duty: for set_pwm
  // phase: 0..1 for beat
}


/api/cue — absolute-time clip

// parse track/preset/t0/t1 → enqueue in scheduler; return 200


/events — SSE telemetry

// every 250ms: event:status data:{"playhead":12345,"fps":[..],"limit":0/1}\n\n

14) Tests (lock behavior)

tests/test_fx_crc.c

TEST_CASE("rainbow CRC", "[fx]"){
  aled_channel_t ch={.ch=0,.type=LED_WS2812B,.n_pixels=60}; px_rgba_t fb[60]; ch.framebuf=fb;
  effect_params_t p={.effect_id=1001,.speed=0.2f,.intensity=1.f,.palette_id=0,.blend=BLEND_NORMAL,.opacity=255};
  memset(fb,0,sizeof fb);
  util_init_gamma(2.2f);
  uint32_t sum = fx_rainbow(&ch,&p, 1234, 0);
  uint32_t crc = crc32_le(0,(uint8_t*)fb,sizeof fb);
  TEST_ASSERT(sum>0);
  TEST_ASSERT_EQUAL_HEX32_MESSAGE(0xA3B5F2D1, crc, "Update CRC after first run.");
}

15) RMT sanity (full timing, if you want it now)

If you want the fully custom encoder today, keep 100 ns resolution and generate rmt_symbol_word_t per bit:

static inline rmt_symbol_word_t sym(uint16_t h, uint16_t l){
  return (rmt_symbol_word_t){ .duration0=h, .level0=1, .duration1=l, .level1=0 };
}

esp_err_t aled_rmt_write(int idx, const px_rgba_t* fb, int npx, led_type_t type){
  const ws_timing_t T = ws2812_t();
  const int stride = (type==LED_SK6812_RGBW)?4:3;
  const int bits = npx*stride*8;
  // Allocate symbol buffer in chunks to avoid large stack (or reuse static ring)
  rmt_encoder_handle_t h=NULL; // skip bytes encoder; we directly send symbols
  rmt_channel_handle_t ch = CH[idx];
  rmt_enable(ch);

  // Chunked transmit:
  const int CHUNK=512; // symbols (not bytes)
  rmt_tx_transmit_config_t tc={0};
  int bi=0; // bit index
  while(bi<bits){
    int take = (bits-bi)>CHUNK? CHUNK:(bits-bi);
    static rmt_symbol_word_t sbuf[CHUNK];
    for(int k=0;k<take;k++){
      int byte_i = (bi+k)/8, bit = 7-((bi+k)%8);
      uint8_t *base = (uint8_t*)fb;
      uint8_t b = base[byte_i];
      sbuf[k] = ((b>>bit)&1) ? sym(T.t1h,T.t1l) : sym(T.t0h,T.t0l);
    }
    rmt_transmit(ch, NULL, sbuf, take*sizeof(rmt_symbol_word_t), &tc); // NULL encoder → raw symbols
    bi += take;
  }
  // reset/latch: 60 µs low
  vTaskDelay(pdMS_TO_TICKS(1));
  return ESP_OK;
}


This avoids the bytes-encoder pitfalls and gives you deterministic timing.

16) UX glue to the Web UI you already have

The UI’s Quick Controls already call /api/trigger with play_preset + set_pwm. Those payloads now map directly to your handlers.

Add a modal editor later by exposing /api/presets (GET list / GET one / PUT / DELETE).

SSE status → show limit badge when the power clamp is active and per-track fps.

17) For the agent (Gemini Flash), do this next

Create new files (fx_util.*, fx_blend.*, fx_palette.*, fx_segments.*, fx_transitions.*, power_budget.*).

Paste the snippets, wire into CMakeLists.txt of led_effects and utils.

Register rainbow/noise/fire/waves in effects.c.

In task_effect_engine.c, implement render order: base → overlay (opacity+blend) → power clamp → RMT write; add fairness by next_deadline_ms.

Add PWM helpers to task_pwm_driver.c.

Implement /api/presets, /api/trigger, /api/cue, /events.

Add unit tests; run once, capture CRCs; paste into assertions.

Confirm 8×120px @ 60 fps with ≥80 KB free heap; clamp engages gracefully when you crank brightness.