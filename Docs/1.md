What’s already defined (so we don’t reinvent it)

Architecture, tasks, components, and web UI are laid out; PCA9685 driver and basic effects are scoped; REST API endpoints are specified.

GPIO / roles / init sequence and performance targets are captured.

Web UI is single-file, responsive, with SSE planned.

Gaps to close next (Phase 2 → Phase 3)

Wi-Fi connection manager; complete REST handlers; mount LittleFS and serve UI; SSE event stream; MQTT pub/sub; implement WS2812/SK6812 RMT driver; basic UDP sync.

1) Wi-Fi connection manager (STA + AP fallback)

Goals

Boot into STA if creds exist; otherwise start AP/captive portal; auto-reconnect; expose /api/wifi POST.

Scaffold (ESP-IDF v5.x C)

// main/tasks/task_wifi.c
#include "esp_wifi.h"
#include "nvs_flash.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "esp_log.h"

typedef struct {
  char ssid[33], pass[65];
} wifi_creds_t;

static const char *TAG = "wifi";
static wifi_creds_t creds;

static void wifi_event_handler(void* arg, esp_event_base_t base, int32_t id, void* data){
  if (base == WIFI_EVENT && id == WIFI_EVENT_STA_DISCONNECTED) {
    esp_wifi_connect(); ESP_LOGW(TAG, "reconnect...");
  } else if (base == IP_EVENT && id == IP_EVENT_STA_GOT_IP) {
    ESP_LOGI(TAG, "got ip");
  }
}

esp_err_t wifi_start_sta(const wifi_creds_t* c){
  ESP_ERROR_CHECK(esp_netif_init());
  ESP_ERROR_CHECK(esp_event_loop_create_default());
  esp_netif_create_default_wifi_sta();
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));
  ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));
  ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL));

  wifi_config_t w = { 0 };
  snprintf((char*)w.sta.ssid, sizeof(w.sta.ssid), "%s", c->ssid);
  snprintf((char*)w.sta.password, sizeof(w.sta.password), "%s", c->pass);
  w.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;

  ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
  ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &w));
  ESP_ERROR_CHECK(esp_wifi_start());
  return esp_wifi_connect();
}


Agent notes

Persist creds in NVS (or your JSON file via storage_fs); call wifi_start_sta() after NVS + FS init in your init sequence step 1–3.

Add /api/wifi POST to set creds, then reboot. (Hook into REST below.)

2) REST API handlers (wire the spec)

Endpoints are defined; handlers are pending. Implement with esp_http_server.

Route table + minimal handlers

// components/rest_api/rest_api.c
#include "esp_http_server.h"
#include "cJSON.h"
#include "esp_system.h"

static httpd_handle_t s_server;

static esp_err_t json_reply(httpd_req_t *req, cJSON *root){
  char *buf = cJSON_PrintUnformatted(root);
  httpd_resp_set_type(req, "application/json");
  httpd_resp_send(req, buf, HTTPD_RESP_USE_STRLEN);
  free(buf); cJSON_Delete(root);
  return ESP_OK;
}

static esp_err_t get_status(httpd_req_t *req){
  cJSON *j = cJSON_CreateObject();
  cJSON_AddStringToObject(j, "node_type", "led-node");
  cJSON_AddStringToObject(j, "role", "Slave");
  cJSON *fps = cJSON_AddObjectToObject(j, "fps");
  cJSON_AddNumberToObject(fps, "aled_ch1", 60);
  cJSON_AddNumberToObject(j, "pwm_max_duty", 0.85);
  cJSON_AddNullToObject(j, "last_error");
  cJSON_AddNumberToObject(j, "heap_free_kb", esp_get_free_heap_size()/1024);
  return json_reply(req, j);
}

static esp_err_t post_trigger(httpd_req_t *req){
  // read body (<=2KB)
  char buf[2048]; int len = httpd_req_recv(req, buf, sizeof(buf)-1); if (len < 0) return ESP_FAIL; buf[len]=0;
  // TODO: parse action { action, target, ... } and forward to trigger_engine
  httpd_resp_set_status(req, "204 No Content"); return httpd_resp_send(req, NULL, 0);
}

esp_err_t rest_api_start(void){
  httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
  if (httpd_start(&s_server, &cfg) != ESP_OK) return ESP_FAIL;
  httpd_uri_t u1 = {.uri="/api/status", .method=HTTP_GET, .handler=get_status};
  httpd_uri_t u2 = {.uri="/api/trigger", .method=HTTP_POST, .handler=post_trigger};
  httpd_register_uri_handler(s_server, &u1);
  httpd_register_uri_handler(s_server, &u2);
  return ESP_OK;
}


Agent notes

Match shapes in your report’s example payload (status).

Add /api/config GET→return JSON, POST→merge+persist; /api/presets CRUD; /api/cue for timeline kicks.

3) Static web server + LittleFS + SSE

You already planned ui_server + storage_fs components; implement the glue to mount FS and serve index.html.gz, plus /events for SSE.

Mount LittleFS

// components/storage_fs/storage_fs.c
#include "esp_littlefs.h"
esp_err_t fs_mount(void){
  esp_vfs_littlefs_conf_t conf = {
    .base_path = "/spiffs", .partition_label = "storage",
    .format_if_mount_failed = true, .dont_mount = false
  };
  return esp_vfs_littlefs_register(&conf);
}


Serve gzipped UI

// components/ui_server/ui_server.c
static esp_err_t get_root(httpd_req_t *req){
  httpd_resp_set_hdr(req, "Content-Encoding", "gzip");
  httpd_resp_set_type(req, "text/html; charset=utf-8");
  FILE *f = fopen("/spiffs/www/index.html.gz","rb");
  if(!f){ httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "missing"); return ESP_FAIL; }
  char buf[2048]; size_t n;
  while((n=fread(buf,1,sizeof(buf),f))>0){ httpd_resp_send_chunk(req, buf, n); }
  fclose(f); httpd_resp_send_chunk(req, NULL, 0); return ESP_OK;
}


SSE endpoint (/events)

static esp_err_t sse_events(httpd_req_t* req){
  httpd_resp_set_type(req, "text/event-stream");
  httpd_resp_set_hdr(req, "Cache-Control", "no-cache");
  httpd_resp_set_hdr(req, "Connection", "keep-alive");
  httpd_resp_sendstr_chunk(req, ":ok\n\n"); // comment to open stream
  // periodically push: "event: status\\ndata: {json}\\n\\n"
  // integrate with Diagnostics & EffectEngine stats
  return ESP_OK;
}

4) PCA9685 usage (PWM channels 1–8)

Driver is listed implemented; here’s usage in your PWM task to set duty and support fades.

// main/tasks/task_pwm_driver.c
#include "pca9685_driver.h"

void pwm_task(void*){
  pca9685_config_t cfg = {.i2c_port=I2C_NUM_0,.sda=GPIO_NUM_21,.scl=GPIO_NUM_22,.oe_gpio=GPIO_NUM_25};
  pca9685_init(&cfg);
  pca9685_set_pwm_freq(1000);

  // Example: set LEDch1 to 40%
  pca9685_set_duty(0 /*ch0*/, 0.40f);

  // Example fade: 0→85% in 2s with log curve
  pca9685_fade_to(1, 0.85f, 2000, true);
  vTaskDelete(NULL);
}

5) RMT WS2812/SK6812 driver (minimal viable)

Addressable driver is not implemented yet; implement one RMT channel per ALEDch using IDF RMT TX at ~800kHz; map pins per your GPIO table (ALEDch1..8 = 16,4,17,18,19,23,26,27).

Sketch

// components/aled_rmt/aled_rmt.c (new component)
#include "driver/rmt_tx.h"

typedef struct { rmt_channel_handle_t ch; gpio_num_t gpio; } aled_rmt_t;

static rmt_encoder_handle_t ws_encoder;

void aled_rmt_init_channel(aled_rmt_t* h, gpio_num_t pin){
  rmt_tx_channel_config_t cfg = {
    .gpio_num = pin, .clk_src = RMT_CLK_SRC_DEFAULT, .mem_block_symbols = 64,
    .resolution_hz = 10*1000*1000, // 100ns tick
    .trans_queue_depth = 4
  };
  rmt_new_tx_channel(&cfg, &h->ch);

  rmt_bytes_encoder_config_t enc = {}; // or dedicated WS2812 encoder
  rmt_new_bytes_encoder(&enc, &ws_encoder);

  rmt_enable(h->ch);
}

// Convert GRB bytes to RMT bitstream timing (T0H/T0L/T1H/T1L)


Agent notes

For WS2812B: T1H≈800ns, T1L≈450ns; T0H≈400ns, T0L≈850ns; reset > 50µs. Use 100ns ticks for precise coding.

Optimize later with DMA ping-pong.

6) Sync protocol (master/slave UDP multicast)

Sync protocol is defined conceptually (tick/cue, EWMA); implement minimal multicast sender/receiver on 239.10.7.42:45454.

// components/sync_protocol/sync_protocol.c
#include "lwip/sockets.h"

typedef struct { uint32_t ms; uint8_t kind; uint8_t pad[3]; } __attribute__((packed)) sync_packet_t;

static const char *MCAST_GRP = "239.10.7.42";
static const uint16_t MCAST_PORT = 45454;

void sync_tx_task(void*){
  int s = socket(AF_INET, SOCK_DGRAM, 0);
  struct in_addr iaddr; inet_aton(MCAST_GRP, &iaddr);
  struct sockaddr_in addr = {.sin_family=AF_INET, .sin_addr=iaddr, .sin_port=htons(MCAST_PORT)};
  for(;;){
    sync_packet_t p = {.ms = (uint32_t) (esp_timer_get_time()/1000), .kind = 1}; // tick
    sendto(s, &p, sizeof(p), 0, (struct sockaddr*)&addr, sizeof(addr));
    vTaskDelay(pdMS_TO_TICKS(50)); // 20 Hz tick
  }
}


Agent notes

On RX, measure drift = local_ms − pkt.ms; apply EWMA to adjust playhead; only honor cues from configured master.

7) Scheduler + cues

Scheduler module exists; wire /api/cue to enqueue timeline segments; emit events to EffectEngine.

Cue structure

typedef struct {
  char target[16];   // "ALEDch1" or "LEDch3"
  char preset[32];   // effect/preset name
  uint32_t t_start_ms, t_end_ms;
} cue_t;

8) Presets & effects registry

Effects engine exists with four effects; document the ABI to add more and a JSON preset shape.

Preset JSON

{
  "name": "solid_blue",
  "target": "ALEDch1",
  "effect": "solid",
  "params": { "color1": "#2f6cff", "intensity": 0.7, "speed": 1.0 }
}


Register new effect

// components/led_effects/effects.c
typedef void (*fx_render_t)(px_rgba_t* fb, uint16_t n, const effect_params_t* p, uint32_t t_ms);

typedef struct { const char* name; fx_render_t render; } effect_desc_t;

static void fx_rainbow(px_rgba_t* fb, uint16_t n, const effect_params_t* p, uint32_t t){
  for(int i=0;i<n;i++){ float k = fmodf((i*0.02f + t*0.001f*p->speed), 1.0f); fb[i] = hsv_to_rgba(k, 1.0f, p->intensity); }
}

static const effect_desc_t EFFECTS[] = {
  {"solid", fx_solid}, {"gradient", fx_gradient}, {"chase", fx_chase}, {"twinkle", fx_twinkle},
  {"rainbow", fx_rainbow}
};

9) MQTT wrapper (telemetry + control)

Wrapper is listed; wire status publish and command topic subscribe.

// components/mqtt_wrapper/mqtt_wrapper.c
#include "esp_event.h"
#include "mqtt_client.h"

static esp_mqtt_client_handle_t s_mq;

void mqtt_start(const char* uri){
  esp_mqtt_client_config_t c = {.broker.address.uri = uri};
  s_mq = esp_mqtt_client_init(&c);
  esp_mqtt_client_start(s_mq);
  esp_mqtt_client_subscribe(s_mq, "lumigrid/cmd/led-node/+", 0);
}

void mqtt_publish_status(const char* json){
  esp_mqtt_client_publish(s_mq, "lumigrid/tele/led-node/status", json, 0, 0, 0);
}

10) Build system + project wiring

Keep your build flow as documented. Use sdkconfig.defaults for size/perf settings.

Top-level app_main.c skeleton (calls everything in order)

void app_main(void){
  nvs_flash_init();
  fs_mount();                         // LittleFS
  lednode_board_init();               // GPIO/I2C/PCA9685
  effects_init();                     // effect registry
  config_load_or_default();           // JSON defaults on first boot
  wifi_start_sta(&creds);             // from NVS/JSON
  rest_api_start();                   // HTTP + /api/*
  ui_server_start();                  // / -> index.html.gz + /events
  xTaskCreate(effect_engine_task, "fx", 8192, NULL, 5, NULL);
  xTaskCreate(pwm_task,           "pwm", 4096, NULL, 6, NULL);
  xTaskCreate(sync_rx_task,       "sync",4096, NULL, 4, NULL);
  xTaskCreate(mqtt_task,          "mqtt",4096, NULL, 3, NULL);
}

11) Testing plan (now)

Unit targets: mock I²C for PCA9685; effect “golden frame” CRC; sync drift sim.

Integration: REST→effect→hardware path; load test “8×120px @ 60fps”; keep ≥80 KB free heap.

Tiny unit harness (effect CRC)

TEST_CASE("solid effect CRC", "[effects]"){
  px_rgba_t fb[60]; memset(fb,0,sizeof fb);
  effect_params_t p = {.effect_id=1, .intensity=1.0, .color1={0,0,255,255}};
  fx_solid(fb, 60, &p, 0);
  uint32_t crc = crc32_le(0, (uint8_t*)fb, sizeof fb);
  TEST_ASSERT_EQUAL_HEX32(0x5A9C3F21, crc);
}

12) Pin-map quick card (aligns your docs/UI)

ALEDch1..8 → GPIO {16,4,17,18,19,23,26,27}; SDA=21/SCL=22; OE=25. Use this map in board_pinmap.h and the web UI selectors already present.

13) Developer checklist (hand this to your agent)

Implement Wi-Fi manager (STA + AP fallback) and persist creds.

Implement REST: /api/status, /api/config GET/POST (merge+persist), /api/presets CRUD, /api/trigger, /api/cue, /events SSE.

Mount LittleFS and serve index.html.gz; verify UI loads.

Implement PWM task using existing PCA9685 driver; verify duty/fade.

Implement RMT driver for WS2812B/SK6812; run a 60-LED test per channel.

Integrate Sync minimal TX/RX multicast; show drift in /events.

Add MQTT publish/subscribe for status/commands.

Write unit tests and a REST→FX integration smoke test.

Meet performance targets while monitoring heap and loop times.

Handy build/flash incantations

Follow your README/REPORT build steps (IDF v5.x, idf.py build/flash/monitor).