0) File map (where each snippet goes)
components/
  led_effects/
    effects.h              // (you have) add new structs/enums
    effects.c              // add new effects + registry + color utils
    fx_palette.h/.c        // NEW: palette system
    fx_segments.h/.c       // NEW: virtual segments per channel
    fx_blend.h/.c          // NEW: blend ops + crossfade engine
    fx_util.h/.c           // NEW: gamma, dither, hsv, rgbw
  aled_rmt/
    aled_rmt.c/.h          // your WS2812/SK6812 driver (keep)
  pca9685_driver/
    pca9685_driver.c/.h    // your PWM HAL (keep)
main/
  tasks/task_effect_engine.c // call registry, schedule frames, FPS budget
  utils/power_budget.c/.h    // NEW: current estimation + clamps
tests/
  test_effects_crc.c        // unit tests for golden-frame CRCs

1) Effect API extensions (small but powerful)
1.1 Extend effect_params_t (effects.h)
typedef enum { BLEND_NORMAL, BLEND_ADD, BLEND_SCREEN, BLEND_MULTIPLY, BLEND_LIGHTEN } blend_mode_t;

typedef struct {
  uint32_t effect_id;
  float speed;          // generic speed 0..n (px/s, cycles/s)
  float intensity;      // 0..1 scalar
  uint32_t palette_id;  // index into palette registry (optional)
  px_rgba_t color1, color2, color3;
  uint32_t seed;        // per-instance
  blend_mode_t blend;
  uint8_t  opacity;     // 0..255 (for overlays)
  // optional segmenting (virtual sub-ranges within a channel)
  uint16_t seg_start;   // inclusive pixel index
  uint16_t seg_len;
} effect_params_t;

1.2 Effect return contract

Let each render() return the computed power estimate (mA) so the engine can clamp or scale.

typedef uint32_t (*fx_render_fn)(aled_channel_t *ch, const effect_params_t *p,
                                 uint32_t t_ms, uint32_t t_end_ms);

2) Color utilities (gamma + HSV + RGBW mix + ordered dither)

fx_util.h

#pragma once
#include <stdint.h>
#include "effects.h"

void util_init_gamma(float gamma);        // build a 256→256 LUT
uint8_t util_gamma_u8(uint8_t v);         // via LUT
px_rgba_t hsv_to_rgbw(float h, float s, float v, int rgbw); // rgbw=1 for SK6812
px_rgba_t rgb_to_rgbw(px_rgba_t in, float wmix);            // perceptual white split
uint8_t dither_ordered(uint8_t v8, uint16_t x, uint16_t y, uint32_t t_ms);


fx_util.c (extracts)

static uint8_t G[256];

void util_init_gamma(float gamma){
  for(int i=0;i<256;i++){ G[i] = (uint8_t)(powf(i/255.f, gamma)*255.f + 0.5f); }
}
uint8_t util_gamma_u8(uint8_t v){ return G[v]; }

// Simple HSV→RGB, then split to RGBW using max-component heuristic
px_rgba_t hsv_to_rgbw(float h, float s, float v, int rgbw){
  h = fmodf(h,1.f); if(h<0) h+=1.f;
  float r,g,b;
  float i = floorf(h*6.f);
  float f = h*6.f - i;
  float p=v*(1.f-s), q=v*(1.f-f*s), t=v*(1.f-(1.f-f)*s);
  switch((int)i%6){
    case 0: r=v; g=t; b=p; break;
    case 1: r=q; g=v; b=p; break;
    case 2: r=p; g=v; b=t; break;
    case 3: r=p; g=q; b=v; break;
    case 4: r=t; g=p; b=v; break;
    default:r=v; g=p; b=q; break;
  }
  px_rgba_t c = { (uint8_t)(r*255), (uint8_t)(g*255), (uint8_t)(b*255), 0 };
  if(rgbw){
    // Extract shared white (min of rgb scaled) → SK6812 white channel
    uint8_t w = (uint8_t)fminf(fminf(c.r, c.g), c.b);
    c.r -= w; c.g -= w; c.b -= w; c.w = w;
  }
  return c;
}

// Optional finer control for RGBW strips with different white LEDs:
px_rgba_t rgb_to_rgbw(px_rgba_t in, float wmix){
  uint8_t w = (uint8_t)fminf(fminf(in.r, in.g), in.b);
  uint8_t ws = (uint8_t)(w * wmix);
  in.r -= ws; in.g -= ws; in.b -= ws; in.w = ws;
  return in;
}

// 4x4 Bayer ordered dither to tame banding at low brightness
static const uint8_t B4[4][4]={{0,8,2,10},{12,4,14,6},{3,11,1,9},{15,7,13,5}};
uint8_t dither_ordered(uint8_t v8, uint16_t x, uint16_t y, uint32_t t_ms){
  // temporal wobble (very subtle)
  uint8_t b = B4[y&3][x&3];
  uint8_t jitter = (t_ms>>4) & 3; // 0..3
  int val = v8 + ((b + jitter) > 8 ? 1 : 0);
  return (uint8_t)(val>255?255:(val<0?0:val));
}

3) Blend utilities (overlay engine)

fx_blend.h

#pragma once
#include "effects.h"
static inline uint8_t clamp8i(int v){ return v<0?0:(v>255?255:v); }

static inline px_rgba_t blend_apply(blend_mode_t mode, px_rgba_t a, px_rgba_t b){
  px_rgba_t o=a;
  switch(mode){
    case BLEND_ADD:       o.r=clamp8i(a.r+b.r); o.g=clamp8i(a.g+b.g); o.b=clamp8i(a.b+b.b); o.w=clamp8i(a.w+b.w); break;
    case BLEND_SCREEN:    o.r=255-((255-a.r)*(255-b.r)/255); o.g=255-((255-a.g)*(255-b.g)/255); o.b=255-((255-a.b)*(255-b.b)/255); o.w=clamp8i(a.w+b.w); break;
    case BLEND_MULTIPLY:  o.r=(a.r*b.r)/255; o.g=(a.g*b.g)/255; o.b=(a.b*b.b)/255; o.w=clamp8i(a.w+b.w); break;
    case BLEND_LIGHTEN:   o.r=a.r>b.r?a.r:b.r; o.g=a.g>b.g?a.g:b.g; o.b=a.b>b.b?a.b:b.b; o.w=clamp8i(a.w+b.w); break;
    default:              o=b; break; // normal: replace
  }
  return o;
}

4) Palette system

fx_palette.h

#pragma once
#include "effects.h"

typedef struct { uint8_t r,g,b; } rgb8_t;
typedef struct { const char* name; const rgb8_t* keys; uint8_t count; } palette_t;

const palette_t* palette_by_id(uint32_t id);
rgb8_t palette_sample(const palette_t* p, float t); // t in [0,1]


fx_palette.c

#include "fx_palette.h"

static const rgb8_t PAL_OCEAN[] = {{0,64,128},{0,160,255},{0,64,128}};
static const rgb8_t PAL_SUNSET[]={{255,80,0},{255,0,64},{64,0,96}};
static const palette_t REGS[] = {
  {"ocean",  PAL_OCEAN,  sizeof(PAL_OCEAN)/3},
  {"sunset", PAL_SUNSET, sizeof(PAL_SUNSET)/3},
};
const palette_t* palette_by_id(uint32_t id){ if(id<sizeof(REGS)/sizeof(REGS[0])) return &REGS[id]; return &REGS[0]; }

rgb8_t palette_sample(const palette_t* p, float t){
  if(p->count==0) return (rgb8_t){255,255,255};
  float x = t * (p->count-1);
  int i = (int)floorf(x); float u=x-i;
  rgb8_t a = p->keys[i], b = p->keys[i < p->count-1 ? i+1 : i];
  return (rgb8_t){ (uint8_t)(a.r + (b.r-a.r)*u), (uint8_t)(a.g + (b.g-a.g)*u), (uint8_t)(a.b + (b.b-a.b)*u) };
}

5) Virtual segments per channel

fx_segments.h

#pragma once
#include "effects.h"
typedef struct { uint16_t start, len; } segment_t;

static inline segment_t seg_from_params(const aled_channel_t* ch, const effect_params_t* p){
  segment_t s = { .start = p->seg_start, .len = p->seg_len ? p->seg_len : ch->n_pixels };
  if(s.start >= ch->n_pixels){ s.start = 0; s.len = ch->n_pixels; }
  if(s.start + s.len > ch->n_pixels){ s.len = ch->n_pixels - s.start; }
  return s;
}


Use this in each effect to limit write range.

6) New Addressable effects (copy-paste into effects.c)
6.1 Rainbow (palette-aware)
static uint32_t fx_rainbow(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t t_end_ms){
  const palette_t* pal = palette_by_id(p->palette_id);
  segment_t s = seg_from_params(ch,p);
  float spd = p->speed>0 ? p->speed : 0.2f; // cycles per second
  float t = (t_ms/1000.f) * spd;
  uint32_t ma=0;
  for(int i=0;i<s.len;i++){
    float u = fmodf((i/(float)s.len) + t, 1.f);
    rgb8_t c = palette_sample(pal, u);
    px_rgba_t px = {c.r, c.g, c.b, 0};
    // gamma + optional dither
    px.r = util_gamma_u8(dither_ordered(px.r, i, ch->ch, t_ms));
    px.g = util_gamma_u8(dither_ordered(px.g, i, ch->ch, t_ms));
    px.b = util_gamma_u8(dither_ordered(px.b, i, ch->ch, t_ms));
    ch->framebuf[s.start+i] = px;
    ma += px.r + px.g + px.b; // crude mA proxy (scale downstream)
  }
  return ma;
}

6.2 Noise Flow (Perlin-ish lite)
static float hash11(float p){ p = sinf(p*127.1f)*43758.5453f; return p - floorf(p); }
static float noise1(float x){ float i=floorf(x), f=x-i; float a=hash11(i), b=hash11(i+1.f); return a + (b-a)*(f*f*(3-2*f)); }

static uint32_t fx_noise(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s = seg_from_params(ch,p);
  float spd = p->speed>0?p->speed:1.2f;
  float t = (t_ms/1000.f)*spd + p->seed*0.1f;
  uint32_t ma=0;
  for(int i=0;i<s.len;i++){
    float n = noise1(i*0.08f + t); // 0..1
    float v = powf(n, 1.5f) * p->intensity; // shape
    px_rgba_t px = { (uint8_t)(p->color1.r*v), (uint8_t)(p->color1.g*v), (uint8_t)(p->color1.b*v), 0};
    ch->framebuf[s.start+i] = px;
    ma += px.r + px.g + px.b;
  }
  return ma;
}

6.3 Fire (classic)
static uint32_t fx_fire(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s = seg_from_params(ch,p);
  uint32_t ma=0;
  for(int i=0;i<s.len;i++){
    float y = (float)i/s.len;
    float flick = noise1((i*0.15f) + (t_ms*0.006f) + p->seed)*0.7f + 0.3f;
    float heat = powf(1.0f - y, 2.0f) * flick * p->intensity;
    px_rgba_t px = hsv_to_rgbw(0.08f + 0.05f*(1.0f-heat), 1.0f, heat, (ch->type==LED_SK6812_RGBW));
    ch->framebuf[s.start+i] = px; ma += px.r+px.g+px.b+px.w;
  }
  return ma;
}

6.4 Waves (sine blend, beat-sync ready)
static volatile float g_beat = 0.f; // update via audio/beat detector or /api/trigger

static uint32_t fx_waves(aled_channel_t *ch, const effect_params_t *p, uint32_t t_ms, uint32_t _){
  segment_t s = seg_from_params(ch,p);
  float t = t_ms/1000.f;
  uint32_t ma=0;
  for(int i=0;i<s.len;i++){
    float x = (float)i/s.len;
    float w = 0.5f + 0.5f*sinf( (x*6.283f*2) + (t*2.0f) + g_beat*0.5f );
    px_rgba_t a=p->color1, b=p->color2;
    px_rgba_t px = { (uint8_t)(a.r + (b.r-a.r)*w),
                     (uint8_t)(a.g + (b.g-a.g)*w),
                     (uint8_t)(a.b + (b.b-a.b)*w), 0 };
    ch->framebuf[s.start+i] = px; ma += px.r+px.g+px.b;
  }
  return ma;
}

7) New PWM “effects” (breath, candle, theater warm-dim)

In your task_pwm_driver.c, add small helpers driven by the scheduler or trigger engine.

typedef struct { uint8_t ch; float target; float cur; uint32_t t0; uint32_t dur; bool logc; } pwm_anim_t;
static pwm_anim_t anims[8];

void pwm_breath(uint8_t ch, float minv, float maxv, float period_ms, uint32_t t_ms){
  float phase = fmodf(t_ms/period_ms, 1.f);
  float s = 0.5f - 0.5f*cosf(phase*6.283f); // 0..1
  float d = minv + (maxv-minv)*s;
  pca9685_set_duty(ch, d);
}

void pwm_candle(uint8_t ch, float base, float flick, uint32_t t_ms, uint32_t seed){
  uint32_t x = (t_ms*1664525u + seed*1013904223u);
  float n = ((x>>8)&0xFFFF)/65535.f;
  float d = base + (n-0.5f)*flick; if(d<0) d=0; if(d>1) d=1;
  pca9685_set_duty(ch, d);
}


Use scheduler to call these per tick (e.g., 50–100 Hz timer).

8) Effect engine changes (blend, clamp, FPS budget)

In task_effect_engine.c, compute base + overlay, apply blend + opacity, clamp by power budget, then handoff to the RMT driver.

static float g_mA_budget = 8000; // from config
static float g_mA_estimate_scale = 0.20f; // fudge factor: (sum rgbw) * scale = mA

static void render_channel(int idx, uint32_t now){
  aled_channel_t* ch = &aled[idx];
  // 1) BASE
  uint32_t ma_base = base_fx->render(ch, &base_params, now, base_t1);
  // 2) OVERLAY → temp buffer
  px_rgba_t tmp[CH_MAX_PX]; // ensure sized or allocate statically per channel
  memcpy(tmp, ch->framebuf, ch->n_pixels*sizeof(px_rgba_t));
  if(overlay_active){
    uint32_t ma_ovl = overlay_fx->render(ch, &ovl_params, now, ovl_t1);
    for(int i=0;i<ch->n_pixels;i++){
      px_rgba_t a = tmp[i], b = ch->framebuf[i];
      b.r = (b.r * ovl_params.opacity) / 255;
      b.g = (b.g * ovl_params.opacity) / 255;
      b.b = (b.b * ovl_params.opacity) / 255;
      b.w = (b.w * ovl_params.opacity) / 255;
      ch->framebuf[i] = blend_apply(ovl_params.blend, a, b);
    }
  }
  // 3) POWER clamp (simple global scaler)
  uint32_t sum=0; for(int i=0;i<ch->n_pixels;i++){ sum += ch->framebuf[i].r + ch->framebuf[i].g + ch->framebuf[i].b + ch->framebuf[i].w; }
  float est_mA = sum * g_mA_estimate_scale;
  float scale = (est_mA > g_mA_budget ? g_mA_budget/est_mA : 1.f);
  if(scale < 1.f){
    for(int i=0;i<ch->n_pixels;i++){
      ch->framebuf[i].r *= scale; ch->framebuf[i].g *= scale; ch->framebuf[i].b *= scale; ch->framebuf[i].w *= scale;
    }
  }
  // 4) PUSH via RMT
  aled_rmt_write(idx, ch->framebuf, ch->n_pixels, ch->type);
}


FPS fairness

Maintain per-channel next_deadline_ms. After a channel transmits a frame, set next_deadline += (1000/max_fps). In the engine loop, iterate channels ordered by smallest next_deadline.

9) Hooks for beat / external sync into effects

Expose a tiny control API:

// main/utils/trigger_engine.c
void trigger_set_beat(float phase){ g_beat = phase; } // 0..1 ramps on detected beats

// REST hook (POST /api/trigger {"action":"beat","phase":0.0})


Make fx_waves and any strobe-like effect read g_beat.

10) Preset & clip examples (JSON)
10.1 Addressable presets
[
  {
    "preset_name":"ocean_walk",
    "effect_id": 1001,        // rainbow
    "palette_id": 0,          // ocean
    "speed": 0.15,
    "intensity": 1.0,
    "blend": "normal",
    "opacity": 255
  },
  {
    "preset_name":"fireplace",
    "effect_id": 1003,        // fire
    "speed": 1.0,
    "intensity": 0.9,
    "seg_start": 0,
    "seg_len": 120
  }
]

10.2 PWM presets (store as commands to the PWM animator)
[
  {"preset_name":"breath_warm", "type":"pwm", "channel":1, "mode":"breath", "min":0.05, "max":0.6, "period_ms":3000},
  {"preset_name":"candle", "type":"pwm", "channel":2, "mode":"candle", "base":0.2, "flick":0.3}
]

10.3 Sequencer clip
{
  "track":"ALEDch3",
  "preset":"ocean_walk",
  "tStart": 12000,
  "tEnd":  42000,
  "fadeIn": 400,
  "fadeOut": 500
}

11) Unit tests (golden frame CRCs)
// tests/test_effects_crc.c
#include "unity.h"
#include "effects.h"
#include "fx_util.h"

TEST_CASE("rainbow CRC stable", "[fx]"){
  aled_channel_t ch = {.ch=0,.type=LED_WS2812B,.n_pixels=60};
  px_rgba_t fb[60]; ch.framebuf = fb;
  effect_params_t p = {.effect_id=1001,.speed=0.2f,.intensity=1.0f,.palette_id=0, .blend=BLEND_NORMAL, .opacity=255};
  memset(fb, 0, sizeof fb);
  uint32_t ma = fx_rainbow(&ch,&p, 1234, 0);
  uint32_t crc = crc32_le(0, (uint8_t*)fb, sizeof fb);
  TEST_ASSERT_MESSAGE(ma>0, "power estimate should be > 0");
  TEST_ASSERT_EQUAL_HEX32(0xA3B5F2D1, crc);  // update after first run locks baseline
}


First run: print CRC, then paste into the assertion; this keeps effects deterministic.

12) REST: minimal “play preset” to channel(s)
// in /api/trigger handler:
if (strcmp(action,"play_preset")==0){
  const char* target = json_str(doc, "target");  // "ALEDch3" or "LEDch2"
  const char* name   = json_str(doc, "name");
  // lookup preset → fill effect_params_t → set active clip for that track (now..now+dur or sticky)
}

13) SSE telemetry (feed the Web UI)

Every 200–500 ms, push a small blob: playhead, per-channel fps, current limit state.

// ui_server.c
static void sse_push_status(httpd_req_t* req){
  char buf[256];
  int n = snprintf(buf,sizeof(buf),
    "event: status\ndata:{\"playhead\":%u,\"limit\":%d,\"fps\":[%d,%d,%d]}\n\n",
    (unsigned)(esp_timer_get_time()/1000), (int)g_limit_active, fps0,fps1,fps2);
  httpd_resp_send_chunk(req, buf, n);
}

14) Performance & safety guardrails

Memory: allocate one static framebuffer per channel; avoid malloc in render.

RMT: reuse encoders; double-buffer large strips if needed.

Watchdog: feed WDT in engine loop or split work across small time slices.

Power: keep a global clamp (as above) and a per-channel cap (max_brightness).

Thermal/brownout: on fault → PCA9685 OE low + set ALED global scale to 0 for N ms, then gradual restore.

15) IDs for your registry (so presets can reference them)
enum {
  FX_SOLID=1, FX_GRADIENT=2, FX_CHASE=3, FX_TWINKLE=4,
  FX_RAINBOW=1001, FX_NOISE=1002, FX_FIRE=1003, FX_WAVES=1004
};

static const effect_vtable_t EFFECTS[] = {
  {FX_SOLID,   "solid",    fx_solid_init,   fx_solid},
  {FX_GRADIENT,"gradient", fx_gradient_init,fx_gradient},
  {FX_CHASE,   "chase",    fx_chase_init,   fx_chase},
  {FX_TWINKLE, "twinkle",  fx_twinkle_init, fx_twinkle},
  {FX_RAINBOW, "rainbow",  NULL,            fx_rainbow},
  {FX_NOISE,   "noise",    NULL,            fx_noise},
  {FX_FIRE,    "fire",     NULL,            fx_fire},
  {FX_WAVES,   "waves",    NULL,            fx_waves},
};
