1) Task list (prioritized)

P0 — correctness & testability

Wire Unity test to the build; run CRC and REST path tests in CI.

Implement /api/trigger {"action":"self_test"} that steps through ALED 1→8, then PWM 1→8 with clear timing and color patterns.

Add /api/status fields: aled[].strip_type, aled[].order, pwm_groups[] (see schemas below).

Add addressable timing presets (WS2812B, SK6812_RGBW) and per-channel color order (e.g., GRB, RGBW).

P1 — feature upgrades

PWM groups → logical fixtures: RGB and RGBW mapping to PCA9685 channels; expose as presets & triggers.

Power telemetry → live power meter in SSE/UI; budget clamp indicator.

Web UI: Quick Actions (Self-Test), Strip Type editor, PWM Group editor.

Sequencer: “Track kind” icons (ALED vs PWM group), per-track mute/solo.

P2 — quality & UX

OTA upload endpoint & UI tile.

Config backup/restore (download/upload JSON).

Discover peers over mDNS; list in Nodes view.

P3 — build & hygiene

Remove response-file workaround if possible; otherwise document it in BUILD.md.

Prune unreferenced components to shrink link steps.

2) Code changes (drop-ins)
2.1 Config schemas (extend your existing default_config.json)

Add per-channel addressable info and PWM grouping:

{
  "aled": [
    {
      "ch": 1,
      "pixels": 120,
      "strip_type": "WS2812B",   // or "SK6812_RGBW"
      "order": "GRB",            // "GRB","RGB","RGBW" (must match strip_type)
      "gamma": 2.2,
      "max_fps": 90,
      "mA_per_led": 45
    }
    // ...
  ],
  "pwm": [
    { "ch":1, "freq_hz":1000, "curve":"log", "soft_start_ms":150, "max_duty":0.85 },
    { "ch":2, "freq_hz":1000, "curve":"linear", "soft_start_ms":0, "max_duty":1.0 }
    // ...
  ],
  "pwm_groups": [
    {
      "name":"BarLeft_RGB",
      "kind":"RGB",              // "RGB" or "RGBW"
      "map": { "R":1, "G":2, "B":3 }  // PCA9685 channels 0..7 (1..8 in human UI)
    },
    {
      "name":"WallRGBW",
      "kind":"RGBW",
      "map": { "R":4, "G":5, "B":6, "W":7 }
    }
  ],
  "power_limits": { "aled_global_mA": 8000, "v5_max_A": 10.0 }
}


Persist these via /api/config POST (merge).

2.2 Enumerations & helpers (addressable types + order)

components/led_effects/effects.h — extend types:

typedef enum { LED_WS2812B=0, LED_SK6812_RGBW=1 } led_type_t;
typedef enum { ORDER_RGB=0, ORDER_GRB=1, ORDER_RGBW=2, ORDER_GRBW=3 } color_order_t;

typedef struct {
  int ch;                 // 0..7
  led_type_t type;        // per-config (WS2812B or SK6812_RGBW)
  color_order_t order;    // GRB/RGB/RGBW/GRBW
  uint16_t n_pixels;
  float gamma;
  uint8_t max_brightness; // 0..255
  px_rgba_t *framebuf;
} aled_channel_t;


components/aled_rmt/aled_rmt.h — pass order into writer:

esp_err_t aled_rmt_write(int idx, const px_rgba_t* fb, int npx,
                         led_type_t type, color_order_t order);


components/aled_rmt/aled_rmt.c — pack bytes by order:

static inline void write_pixel_bytes(uint8_t* out, px_rgba_t p, color_order_t ord, bool rgbw){
  switch(ord){
    case ORDER_GRB:   out[0]=p.g; out[1]=p.r; out[2]=p.b; break;
    case ORDER_RGB:   out[0]=p.r; out[1]=p.g; out[2]=p.b; break;
    case ORDER_RGBW:  out[0]=p.r; out[1]=p.g; out[2]=p.b; out[3]=p.w; break;
    case ORDER_GRBW:  out[0]=p.g; out[1]=p.r; out[2]=p.b; out[3]=p.w; break;
  }
}


Use this inside your frame→RMT conversion (same timing logic you already have).

2.3 PWM grouping API (RGB/RGBW fixtures)

firmware/main/tasks/task_pwm_driver.h — new group API:

typedef enum { PWMG_RGB=0, PWMG_RGBW=1 } pwm_group_kind_t;

typedef struct {
  char name[24];
  pwm_group_kind_t kind;
  int map_r, map_g, map_b, map_w;  // 0..7 PCA9685 logical channels
} pwm_group_t;

void pwm_groups_init_from_config(void);
void pwm_group_set_rgb(const char* name, float r, float g, float b);             // 0..1
void pwm_group_set_rgbw(const char* name, float r, float g, float b, float w);   // 0..1


firmware/main/tasks/task_pwm_driver.c — minimal impl:

static pwm_group_t groups[8];
static int groups_len=0;

void pwm_groups_init_from_config(void){
  // read from config JSON; fill groups[] and groups_len
}

static inline void set_ch(int ch, float v){ if(ch>=0 && ch<8) pca9685_set_duty(ch, v); }

void pwm_group_set_rgb(const char* name, float r, float g, float b){
  for(int i=0;i<groups_len;i++) if(strcmp(groups[i].name,name)==0){
    set_ch(groups[i].map_r, r); set_ch(groups[i].map_g, g); set_ch(groups[i].map_b, b); return;
  }
}

void pwm_group_set_rgbw(const char* name, float r, float g, float b, float w){
  for(int i=0;i<groups_len;i++) if(strcmp(groups[i].name,name)==0){
    set_ch(groups[i].map_r, r); set_ch(groups[i].map_g, g); set_ch(groups[i].map_b, b); set_ch(groups[i].map_w, w); return;
  }
}


Now presets & triggers can target pwm_group.name instead of raw channels.

2.4 REST: new actions & fields

components/rest_api/rest_api.c — in /api/status payload:

// add:
cJSON *aled = cJSON_AddArrayToObject(j, "aled");
for(int i=0;i<8;i++){
  cJSON *a = cJSON_CreateObject();
  cJSON_AddNumberToObject(a, "ch", i+1);
  cJSON_AddStringToObject(a, "strip_type", (aled[i].type==LED_SK6812_RGBW)?"SK6812_RGBW":"WS2812B");
  cJSON_AddStringToObject(a, "order", (aled[i].order==ORDER_GRB)?"GRB":"RGBW"); // etc.
  cJSON_AddItemToArray(aled, a);
}
cJSON *pg = cJSON_AddArrayToObject(j, "pwm_groups");
for(int k=0;k<groups_len;k++){
  cJSON *g = cJSON_CreateObject();
  cJSON_AddStringToObject(g, "name", groups[k].name);
  cJSON_AddStringToObject(g, "kind", groups[k].kind==PWMG_RGBW?"RGBW":"RGB");
  cJSON_AddItemToArray(pg, g);
}


/api/trigger — add handlers:

if (strcmp(action,"self_test")==0) { self_test_run(); reply204(); return ESP_OK; }

if (strcmp(action,"set_pwm_group")==0){
  const char* name = json_str(root,"name");
  if (json_has(root,"w")) pwm_group_set_rgbw(name, jnum(root,"r"), jnum(root,"g"), jnum(root,"b"), jnum(root,"w"));
  else pwm_group_set_rgb(name, jnum(root,"r"), jnum(root,"g"), jnum(root,"b"));
  reply204(); return ESP_OK;
}

if (strcmp(action,"set_strip_type")==0){
  int ch = jnum(root,"ch")-1;
  const char* t = json_str(root,"strip_type"); // "WS2812B" or "SK6812_RGBW"
  const char* ord = json_str(root,"order");    // "GRB","RGB","RGBW","GRBW"
  lednode_set_strip_type(ch, t, ord);          // persist + apply (see below)
  reply204(); return ESP_OK;
}

2.5 Apply & persist strip type/order

firmware/main/lednode_init.c — add:

void lednode_set_strip_type(int ch, const char* t, const char* ord){
  if(ch<0 || ch>=8) return;
  if(strcmp(t,"SK6812_RGBW")==0) aled[ch].type = LED_SK6812_RGBW;
  else aled[ch].type = LED_WS2812B;

  if(strcmp(ord,"GRB")==0) aled[ch].order=ORDER_GRB;
  else if(strcmp(ord,"RGB")==0) aled[ch].order=ORDER_RGB;
  else if(strcmp(ord,"RGBW")==0) aled[ch].order=ORDER_RGBW;
  else aled[ch].order=ORDER_GRBW;

  config_update_aled(ch, t, ord);  // write JSON & save
}

2.6 One-button Self-Test (ALED & PWM, sequential)

firmware/main/utils/self_test.c (new):

#include "self_test.h"
#include "task_pwm_driver.h"
#include "effects.h"
#include "aled_rmt.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static void test_task(void*){
  // Addressable: ch1..8, show RGBW bursts
  px_rgba_t px[8]; for(int i=0;i<8;i++){ px[i]=(px_rgba_t){0,0,0,0}; }
  const px_rgba_t colors[] = {{255,0,0,0},{0,255,0,0},{0,0,255,0},{0,0,0,255}};
  for(int ch=0; ch<8; ch++){
    for(int c=0;c<4;c++){
      for(int i=0;i<8;i++) px[i]=colors[c];
      aled_rmt_write(ch, px, 8, aled[ch].type, aled[ch].order);
      vTaskDelay(pdMS_TO_TICKS(250));
    }
    // off
    for(int i=0;i<8;i++) px[i]=(px_rgba_t){0,0,0,0};
    aled_rmt_write(ch, px, 8, aled[ch].type, aled[ch].order);
  }

  // PWM: ch1..8, 30% then off
  for(int p=0;p<8;p++){ pca9685_set_duty(p, 0.3f); vTaskDelay(pdMS_TO_TICKS(300)); pca9685_set_duty(p, 0.0f); }
  vTaskDelete(NULL);
}

void self_test_run(void){
  xTaskCreate(test_task, "self_test", 4096, NULL, 3, NULL);
}


firmware/main/utils/self_test.h

#pragma once
void self_test_run(void);


Wire to REST (self_test_run(); as shown above).

2.7 Effect engine: use new writer signature

Where you push frames:

aled_rmt_write(idx, ch->framebuf, ch->n_pixels, ch->type, ch->order);

2.8 Unity tests in build

firmware/CMakeLists.txt (excerpt):

idf_component_register( ... REQUIRES unity )

if(CONFIG_COMPILER_CXX_EXCEPTIONS)  # or guard with option
  unity_add_basic_test(NAME fx_crc TEST_SRC "main/tests/test_fx_crc.c")
endif()


firmware/main/tests/test_fx_crc.c — ensure included & run by idf.py test.

3) Web UI upgrades (kept ESP-friendly)

Your current single-file UI is the right footprint for ESP. Let’s add three things without pulling heavy frameworks:

Self-Test button (one call to /api/trigger).

Strip Type editor (per ALED channel).

PWM Group editor (define and tweak RGB/RGBW groups).

3.1 Quick Actions → Self-Test

In Dashboard template, add:

<button class="btn ghost" id="btn-selftest">Self-Test</button>


In dashboard hydrate:

document.getElementById('btn-selftest').onclick =
  ()=> API.trigger({action:'self_test'});

3.2 Strip Type editor (Settings view)

Add a small table:

<section class="card" style="margin-top:16px">
  <h2 style="margin:0 0 8px">Addressable Strip Types</h2>
  <table><thead><tr><th>Channel</th><th>Type</th><th>Order</th><th></th></tr></thead>
  <tbody id="aled-type-body"></tbody></table>
</section>


Hydrate code:

async function loadAledTypes(){
  const s = await API.status();
  const tbody = document.getElementById('aled-type-body');
  tbody.innerHTML = (s.aled||[]).map(a=>{
    return `<tr>
      <td>ALEDch${a.ch}</td>
      <td><select data-ch="${a.ch}" data-k="type">
            <option ${a.strip_type==='WS2812B'?'selected':''}>WS2812B</option>
            <option ${a.strip_type==='SK6812_RGBW'?'selected':''}>SK6812_RGBW</option>
          </select></td>
      <td><select data-ch="${a.ch}" data-k="order">
            <option ${a.order==='GRB'?'selected':''}>GRB</option>
            <option ${a.order==='RGB'?'selected':''}>RGB</option>
            <option ${a.order==='RGBW'?'selected':''}>RGBW</option>
            <option ${a.order==='GRBW'?'selected':''}>GRBW</option>
          </select></td>
      <td><button class="btn small ghost" data-save="${a.ch}">Save</button></td>
    </tr>`;
  }).join('');
  tbody.querySelectorAll('button[data-save]').forEach(b=>{
    b.onclick = ()=>{
      const ch = +b.dataset.save;
      const type = tbody.querySelector(`select[data-ch="${ch}"][data-k="type"]`).value;
      const order = tbody.querySelector(`select[data-ch="${ch}"][data-k="order"]`).value;
      API.trigger({action:'set_strip_type', ch, strip_type:type, order});
    };
  });
}


Call loadAledTypes() inside renderSettings().

3.3 PWM Group editor (Settings)

UI block:

<section class="card" style="margin-top:16px">
  <h2 style="margin:0 0 8px">PWM Groups</h2>
  <div class="grid cols-2">
    <div>
      <label>Name</label><input id="pg-name" class="input" />
      <label>Kind</label>
      <select id="pg-kind"><option>RGB</option><option>RGBW</option></select>
      <div class="grid cols-2" style="margin-top:8px">
        <div><label>R → ch</label><input id="pg-r" class="input" type="number" min="1" max="8"></div>
        <div><label>G → ch</label><input id="pg-g" class="input" type="number" min="1" max="8"></div>
        <div><label>B → ch</label><input id="pg-b" class="input" type="number" min="1" max="8"></div>
        <div id="pg-w-wrap" style="display:none"><label>W → ch</label><input id="pg-w" class="input" type="number" min="1" max="8"></div>
      </div>
      <button class="btn" id="pg-save" style="margin-top:8px">Save Group</button>
    </div>
    <div>
      <div id="pg-list" class="k">No groups yet.</div>
    </div>
  </div>
</section>


Hydrate:

document.getElementById('pg-kind').onchange = (e)=>{
  document.getElementById('pg-w-wrap').style.display = e.target.value==='RGBW'?'block':'none';
};

document.getElementById('pg-save').onclick = async ()=>{
  const body = {
    pwm_groups: [{
      name: document.getElementById('pg-name').value.trim(),
      kind: document.getElementById('pg-kind').value,
      map: {
        R: +document.getElementById('pg-r').value-1,
        G: +document.getElementById('pg-g').value-1,
        B: +document.getElementById('pg-b').value-1,
        W: +((document.getElementById('pg-w')?.value||0)-1)
      }
    }]
  };
  await API.configPost(body);
  // refresh list
  const s = await API.status();
  document.getElementById('pg-list').textContent = (s.pwm_groups||[]).map(g=>`${g.name} (${g.kind})`).join(', ');
};

3.4 Live power meter (SSE)

SSE handler (UI):

const evt = new EventSource('/events');
evt.onmessage = (e)=>{ /* generic */ };
evt.addEventListener('status', (e)=>{
  const d = JSON.parse(e.data);
  // Expect d.limit (0/1) and d.power_mA or d.power_pct
  document.getElementById('tick-lag').textContent = `Power: ${d.power_mA||'—'} mA`;
});


Server: periodically include power_mA and limit in /events.

4) “Most modern tech available on ESP32” (without bloat)

Keep: single-file UI (no heavy frameworks), compressed with gzip, served with long-cache headers.

Modernize via Web Components? On ESP32, that typically costs too much JS parse/heap. We stick to vanilla JS + templates and progressive enhancement—it’s the sweet spot for speed and memory.

Optional (desktop editor build only): author UI in Svelte/Preact, then export a single, framework-less bundle (no runtime) using compile-time templating. On-device you still ship one gzipped HTML.

5) Quick verification script (curl)
# Set strip type/order for ALED ch1
curl -sX POST http://node.local/api/trigger \
  -H 'Content-Type: application/json' \
  -d '{"action":"set_strip_type","ch":1,"strip_type":"SK6812_RGBW","order":"GRBW"}'

# Create PWM RGB group
curl -sX POST http://node.local/api/config \
  -H 'Content-Type: application/json' \
  -d '{"pwm_groups":[{"name":"BarLeft_RGB","kind":"RGB","map":{"R":0,"G":1,"B":2}}]}'

# Drive the group to purple
curl -sX POST http://node.local/api/trigger \
  -H 'Content-Type: application/json' \
  -d '{"action":"set_pwm_group","name":"BarLeft_RGB","r":0.6,"g":0.0,"b":0.6}'

# Run self-test
curl -sX POST http://node.local/api/trigger \
  -H 'Content-Type: application/json' \
  -d '{"action":"self_test"}'